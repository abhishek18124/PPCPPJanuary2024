// https://leetcode.com/problems/minimize-malware-spread/

template <typename T>
class disjoinSet {

public :

    unordered_map<T, T> parentMap;
    unordered_map<T, int> rankMap;

    void createSet(T u) {
        parentMap[u] = u;
        rankMap[u] = 1;
    }

    T findSet(T u) {
        // base case
        if (parentMap[u] == u) {
            return u;
        }

        // recursive case
        return parentMap[u] = findSet(parentMap[u]);
    }

    void unionSet(T u, T v) {

        T l_u = findSet(u);
        T l_v = findSet(v);

        if (l_u != l_v) {
            if (rankMap[l_u] > rankMap[l_v]) {
                // make l_u the leader of l_v
                parentMap[l_v] = l_u;
                rankMap[l_u] += rankMap[l_v];
            } else {
                // make l_v the leader of l_u
                parentMap[l_u] = l_v;
                rankMap[l_v] += rankMap[l_u];
            }
        }

    }

};

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {

        disjoinSet<int> ds;

        int n = graph.size();
        for (int i = 0; i < n; i++) {
            ds.createSet(i);
        }

        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (graph[i][j] == 1) {
                    // ith node is connected with the jth node
                    ds.unionSet(i, j);
                }
            }
        }

        unordered_map<int, int> countMap; // to track no. of malwares in each component represented by the 'leader'

        for (int malware : initial) {
            int leader = ds.findSet(malware);
            countMap[leader]++;
        }

        // vector<int> countMap(n); // to track no. of malwares in each component represented by the 'leader'

        // for (int malware : initial) {
        //     int leader = ds.findSet(malware);
        //     countMap[leader]++;
        // }

        int maxSize = 0;
        int bestMalware = INT_MAX; // to track the malware which infects the largest number of nodes in the graph and is unique in its component and therefore must be eliminated to minimize the spread

        for (int malware : initial) {
            int leader = ds.findSet(malware);
            if (count[leader] == 1) {
                // the component represented by 'leader' contains a single malware
                int size = ds.rankMap[leader]; // represents the no. of nodes in the component in which 'malware' is present
                if (size > maxSize) {
                    // eliminating 'malware' will create the maximum impact in reducing the spread
                    bestMalware = malware;
                    maxSize = size;
                } else if (size == maxSize) {
                    bestMalware = min(malware, bestMalware);
                }
            }
        }

        // return bestMalware;

        return bestMalware == INT_MAX ? *min_element(initial.begin(), initial.end()) : bestMalware;

    }
};